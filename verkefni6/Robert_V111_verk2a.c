#pragma config(Sensor, in1,    clawAngle,      sensorGyro)
#pragma config(Sensor, in3,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in4,    midLine,        sensorLineFollower)
#pragma config(Sensor, in5,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in7,    turnAngle,      sensorPotentiometer)
#pragma config(Sensor, in8,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  bumber,         sensorTouch)
#pragma config(Sensor, dgtl2,  clawStop,       sensorTouch)
#pragma config(Sensor, dgtl4,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, encoder, encoderPort, dgtl7, 1000)
#pragma config(Motor,  port6,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           verticleClawMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed, encoder, encoderPort, None, 1000)
#include "../Headers/consts.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//white 1987 black 2851 threshold 2400
/*----------------------------------------------------------------------------------------------------*\
|*                                         - Moving Forward -                                         *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs your robot to move forward at full power for three seconds.  There is a    *|
|*  two second pause at the beginning of the program.                                                 *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*  			Task display displays battery life on the main bettry and updates every 100 miliseconds.		*|
|*				distance of wheel turn = 5.5*2*PI = 34.56		 																								*|
|*				turn90 turns right(True) or left(False) for 90 degrees																			*|
|*				stopMotor and resetEncoder are utility functions to make things easier											*|
|*				this is version 011 or 3 of Robert Robot here he will go forward half a meter and turn			*|
|*				in a path																																										*|
|*				previous versions are version 001 and 010																										*|
|*				you'll find all versions here:																															*|
|*				https://github.com/kartoflu-supa/rob2a																											*|
|*				in the motors & sensors section you will see the name and port of the motors and Sensors		*|
|*				taskmain:																																										*|
|*					1)Starts by going forward 0.5m																														*|
|*					2)then it enters a for loop of turning 90 degrees after array turns then goes forward 		*|
|*						another 0.5m																																						*|
|*					3)once the loop has counted from 0 to 13 the machine and code stops												*|
|*																																																		*|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor Port 2        rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor Port 3        leftMotor           VEX 3-wire module     Left side motor   								*|
|*		Digital port 1      touchSensor1        VEX 3-wire module     Front bumber sensor								*|
|*		Digital port 2      touchSensor2        VEX 3-wire module     Claw stop sensor									*|
|*		Analog port 8       lightSensor         VEX 3-wire module     Ambient light sensor							*|
|*		Digital port 4      sonarSensor         VEX 3-wire module     Front distance sensor							*|
|*		Digital port 5      sonarSensor  				VEX 3-wire module     Front distance sensor							*|
|*		Digital port 7-8    rightEncoder 				VEX 3-wire module			Left side encoder									*|
|*		Digital port 10-11  leftEncoder				  VEX 3-wire module			Right side encoder								*|
|*		Analog port 1       poteniometer				VEX 3-wire module			Claw poteniometer									*|
\*----------------------------------------------------------------------------------------------------*/
bool l_s = false;
bool r_s = false;

task display(){
		bLCDBacklight = true;									// Turn on LCD Backlight
	string mainBattery, backupBattery;

	while(true)
	{
		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c",);
		displayNextLCDString(mainBattery);

		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);

		wait1Msec(100);
	}
}




task control(){
	bool active = true;
	while(1==1){
		if (!(vexRT[Btn8U] == 0 && SensorValue[bumber] == 0)){active = true;}
		while(active){
			hogCPU();
			motor[rightMotor]  = vexRT[Ch2];  // (y + x)/2
			motor[leftMotor] = vexRT[Ch3];

// Raise, lower or do not move arm
			if(vexRT[Btn5D] == 1){
				motor[verticleClawMotor] = 127;    	//...raise the arm.
			}
			else if(vexRT[Btn5U] == 1){
				motor[verticleClawMotor] = -127;   	//...lower the arm.
			}
			else{
				motor[verticleClawMotor] = 0;      	//...stop the arm.
			}

// Open, close or do not move claw
			if(vexRT[Btn6U] == 1){
				motor[clawMotor] = 127;}
			else if(vexRT[Btn6D] == 1){
				motor[clawMotor] = -127; 		//...open the gripper.
			}
			else{
				motor[clawMotor] = 0;    		//...stop the gripper.
				}
			if (vexRT[Btn8D] > 0){
				wait1Msec(500);
				active = false;
				releaseCPU();
	 			StartTask(display);
				}
			}
		}
	}
void stopMotor() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
void resetEncoder(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void turn90(bool l_r) {
	int turn_num = BASE_DEG*80;
	resetEncoder();
	if (l_r) {
		while(abs(SensorValue[leftEncoder]) < turn_num || abs(SensorValue[rightEncoder]) < turn_num){

		if (abs(SensorValue[leftEncoder]) < turn_num){motor[leftMotor] = FULL_FORWARD;}
		if (abs(SensorValue[rightEncoder]) < turn_num){motor[rightMotor] = FULL_FORWARD * -1;}
	}}
	else {
		while(abs(SensorValue[leftEncoder]) < turn_num || abs(SensorValue[rightEncoder]) < turn_num){
		if (abs(SensorValue[leftEncoder]) < turn_num){motor[leftMotor] = FULL_FORWARD * -1;}
		if (abs(SensorValue[rightEncoder])< turn_num){motor[rightMotor] = FULL_FORWARD;}
	}}
	stopMotor();
}
int i = 0;
//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	StartTask(display);
	while(true){
		while(SensorValue[midLine] > 2400){
			if (SensorValue[sonar] < 20 && SensorValue[sonar] != -1) {
				i++;
			}

			motor[leftMotor] = 32;
			motor[rightMotor] = 32;
			r_s = SensorValue[rightLine] > 2400;
			l_s = SensorValue[leftLine] > 2400;
		}
		if (l_s == true){
			motor[leftMotor] = 0;
			motor[rightMotor] = 64;
		}
		if (r_s == true){
			motor[leftMotor] = 64;
			motor[rightMotor] = 0;
		}
		}

	stopMotor();
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
